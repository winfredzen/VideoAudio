# YUV视频采集

在Mac上采集YUV视频，大致过程与采集音频PCM数据类似

有一下需要注意的地方：

1.app的摄像头权限

2.如果没有设置帧率，控制输出会提示如下的内容，表示默认的帧率不被支持，并列出支持的帧率

![066](https://github.com/winfredzen/VideoAudio/blob/main/Basic/image/066.png)

![067](https://github.com/winfredzen/VideoAudio/blob/main/Basic/image/067.png)

设置帧率

```
av_dict_set(&options, "framerate", "30", 0);//帧率
```

3.默认的采样格式yuv420p，mac不支持，会有如下的提示，默认使用的是`uyvy422`

![068](https://github.com/winfredzen/VideoAudio/blob/main/Basic/image/068.png)

4.注意`AVPacket`采样大小，如下：

![069](https://github.com/winfredzen/VideoAudio/blob/main/Basic/image/069.png)

如何计算大小对不对呢？

比如采样的大小是`640x480`，按`yuv422`算，一帧大小为`(640*480*1 + 640*480*0.5*2 = 61440) `

即y分量一个字节，u、v分量各0.5个字节

5.采样后，播放，格式和分辨率要对上

```shell
ffplay -pix_fmt uyvy422  -s 640x480 video.yuv
```

6.设置像素的格式（采样格式）

```c
av_dict_set(&options,"pixel_format","nv12", 0);//采样格式
```

`nv12`是属于`yuv420sp` ，大小为`(640*480*1 + 640*480*0.5 = 460800) `

但packet大小就不是这个值了

![070](https://github.com/winfredzen/VideoAudio/blob/main/Basic/image/070.png)

所以写入的时候`fwrite(pkt.data, 1, pkt.size, file);`这个大小，就要变化下

```c
fwrite(pkt.data, 1, 460800, file);
```

此时播放就要使用

```shell
ffplay -pix_fmt nv12  -s 640x480 video.yuv
```



## 代码

录制视频的主要代码：

```c
#include "testc.h"

//录制状态
static int rec_status = 0;

//打开设备
static AVFormatContext* open_dev() {
    int ret = 0;
    //出错信息
    char errors[1024] = {0, };
    
    AVFormatContext *fmt_ctx = NULL;
    AVDictionary *options = NULL;
    
    //格式[[VIDEO]:[AUDIO]]，只采集视频 0 -表示摄像头 1- 表示桌面
    char *devciename = "0";
    
    //register audio device
    avdevice_register_all();
    
    //get格式
    AVInputFormat *inputFormat = av_find_input_format("avfoundation");
    
    //采集视频需要设置一些参数
    enum AVPixelFormat av_fmt = AV_PIX_FMT_NV12;
    av_dict_set(&options, "video_size", "640x480", 0);//分辨率
    av_dict_set(&options, "framerate", "30", 0);//帧率
    av_dict_set(&options,"pixel_format","nv12", 0);//采样格式 nv12=yuv420sp
    
    
    //打开输入设备
    ret = avformat_open_input(&fmt_ctx, devciename, inputFormat, &options);
    if (ret < 0) {
        av_strerror(ret, errors, 1024);
        fprintf(stderr, "Failded to open device [%d]%s\n", ret, errors);
        return NULL;
    }
    return fmt_ctx;
}


void record_video() {
    printf("This is c function\n");
    
    AVFormatContext *fmt_ctx = NULL;
    int ret = 0;
    //读数据
    AVPacket pkt;

    av_log_set_level(AV_LOG_DEBUG);
    av_log(NULL, AV_LOG_DEBUG, "Hello FFmpeg!!!\n");
    
    rec_status = 1;
    
    //创建文件
    char *out = "/Users/wangzhen/Downloads/video.yuv";
    FILE *file = fopen(out, "wb+");
    if (!file) {
        printf("file == NUL");
        goto __ERROR;
    }
    
    //打开设备
    fmt_ctx = open_dev();
    if (!fmt_ctx) {
        printf("fmt_ctx == NULL\n");
        goto __ERROR;
    }
    
    //实时录制
    while (rec_status) {
        ret = av_read_frame(fmt_ctx, &pkt);
        if(ret == -35) {
            ret = 0;
            av_packet_unref(&pkt);
            continue;
        }

        if(ret < 0){
            av_packet_unref(&pkt);
            break;
        }
        printf("pkt size %d(%p)\n", pkt.size, pkt.data); //pkt size 2048(0x1048d3a00) 0

        //写文件
        //fwrite(pkt.data, 1, pkt.size, file);
        fwrite(pkt.data, 1, 460800, file);
        fflush(file);
        
        av_packet_unref(&pkt);
    }
    
__ERROR:

    //关闭设备释放上下文
    if (fmt_ctx) {
        avformat_close_input(&fmt_ctx);
    }
    
    //关闭文件
    if (file) {
        fclose(file);
    }
    

    av_log(NULL, AV_LOG_DEBUG, "Finish!!!\n");
    return;
}



void set_status(int status) {
    rec_status = status;
}

```



## 其它

YUV格式的一些介绍：

+ [Recommended 8-Bit YUV Formats for Video Rendering](https://docs.microsoft.com/en-us/windows/win32/medfound/recommended-8-bit-yuv-formats-for-video-rendering#uyvy)























