# 音频采集

采集音频的方法

1.Android

+ AudioRecord
+ MediaRecorder

2.iOS

+ AudioUnit
+ AVFoundation



**FFmpeg采集音频**

1.通过命令的方式

2.通过API的方式



## FFmpeg中MacOS的操作

1.查看设备列表

```shell
ffmpeg -devices
```

![018](https://github.com/winfredzen/VideoAudio/blob/main/Basic/image/018.png)

包括

+ 解封装或封装的支持情况
+ 设备列表



上面的输出设备中包含`avfoundation`，在FFmpeg官方文档中对[AVFoundation](https://ffmpeg.org/ffmpeg-devices.html#toc-avfoundation)有介绍

> AVFoundation input device.
>
> AVFoundation is the currently recommended framework by Apple for streamgrabbing on OSX >= 10.7 as well as on iOS.
>
> The input filename has to be given in the following syntax:
>
> ```
> -i "[[VIDEO]:[AUDIO]]"
> ```
>
> The first entry selects the video input while the latter selects the audio input. The stream has to be specified by the device name or the device index as shown by the device list. Alternatively, the video and/or audio input device can be chosen by index using the -video_device_index <INDEX> and/or -audio_device_index <INDEX> , overriding any device name or index given in the input filename.
>
> All available devices can be enumerated by using -list_devices true, listing all device names and corresponding indices.



例如`-i "[[VIDEO]:[AUDIO]]"`，第一个表示视频输入，第二个表示音频输入



枚举AVFoundation支持的输入设备

```shell
ffmpeg -f avfoundation -list_devices true -i ""
```

![019](https://github.com/winfredzen/VideoAudio/blob/main/Basic/image/019.png)



2.采集视频

参考：

+ [(FFmpeg) How to record a MacOS Screen with terminal?](http://johnriselvato.com/ffmpeg-how-to-record-macos-screen/)



如：

```shell
ffmpeg -f avfoundation -r 30 -s 1280x720 -i "0:0"  output.mkv
```





3.采集音频

```shell
ffmpeg -f avfoundation -i ":0" out.wav
```

播放

```shell
ffplay out.wav
```





## Mac App实现

1.导入lib库和头文件

2.xcode设置path



![020](https://github.com/winfredzen/VideoAudio/blob/main/Basic/image/020.png)



**采集音频的步骤**

+ 注册设备
+ 设置采集方式 avfoundation/dshow/alsa
+ 打开音频设备



在试验中遇到的一些问题：

1.swift中调用c函数，需要桥接文件

2.`avformat_open_input`报错如"Protocol not found"，需要添加麦克风访问权限，在`info.plis`t和`Capabilities`中都要设置

3.`av_read_frame`一直返回`-35`，原因是设备还没有准备好，可以使用延时，或者循环等待

4.`fopen`打开文件返回NULL，文件访问权限的原因，可

> Signing & Capabilities -> App Sandbox -> File Access Type 其中Downloads Folder 的权限修改为Read/Write

5.`ffplay -ar 44100 -ac 1 -f f32le audio.pcm`使用ffplay播放pcm录音

例如，我在mac上使用耳机的麦克风来录音，我怎么知道采样率、通道、采样大小是多少呢？

可通过mac上的**音频MIDI设置**程序来查看，如：

![021](https://github.com/winfredzen/VideoAudio/blob/main/Basic/image/021.png)



另一种方式是，录制一个音频，如`ffmpeg -f avfoundation -i ":0" out.wav`，从输出就可以看出来

![023](https://github.com/winfredzen/VideoAudio/blob/main/Basic/image/023.png)



## 录制PCM音频

主要代码实现如下：

```c
#include "testc.h"

//录制状态
static int rec_status = 0;

void record_audio() {
    printf("This is c function\n");
    
    av_log_set_level(AV_LOG_DEBUG);
    av_log(NULL, AV_LOG_DEBUG, "Hello FFmpeg!!!\n");
    
    AVFormatContext *fmt_ctx = NULL;
    
    //格式[[VIDEO]:[AUDIO]] 下面的格式表示音频设备
    char *devciename = ":0";
    
    AVDictionary *options = NULL;
    
    //出错信息
    char errors[1024];
    
    //注册设备
    avdevice_register_all();
    
    //get格式
    AVInputFormat *inputFormat = av_find_input_format("avfoundation");
    
    //打开输入设备
    int ret = avformat_open_input(&fmt_ctx, devciename, inputFormat, &options);
    
    if (ret < 0) {
        av_strerror(ret, errors, 1024);
        printf(stderr, "Failded to open device [%d]%s\n", ret, errors);
        return;
    }
    
    //创建文件
    char *out = "/Users/wangzhen/Downloads/audio.pcm";
    FILE *file = fopen(out, "wb+");
    if (file == NULL) {
        printf("file == NUL");
    }
    
    //读数据
    AVPacket pkt;
    av_init_packet(&pkt);
    int count = 0;
    ret = 0;

    //来时录制
    rec_status = 1;
    while (rec_status) {
        ret = av_read_frame(fmt_ctx, &pkt);
        if(ret == -35) {
            ret = 0;
            av_packet_unref(&pkt);
            continue;
        }

        if(ret < 0){
            av_packet_unref(&pkt);
            break;
        }
        printf("pkt size %d(%p) %d\n", pkt.size, pkt.data, count);

        //写入文件
        fwrite(pkt.data, pkt.size, 1, file);
        fflush(file);

        av_packet_unref(&pkt);
    }
    
    //关闭问价
    fclose(file);
    
    //释放上下文
    avformat_close_input(&fmt_ctx);
    
    
    av_log(NULL, AV_LOG_DEBUG, "Finish!!!\n");
    return;
}

void set_status(int status) {
    rec_status = status;
}

```



## 其它

其它可参考：

+ [【秒懂音视频开发】08_音频录制02_编程 ](https://www.cnblogs.com/mjios/p/14540642.html)



1.`ffplay -ar 44100 -ac 1 -f f32le audio.pcm`的含义

参考：

+ [【秒懂音视频开发】09_播放PCM ](https://www.cnblogs.com/mjios/p/14581738.html)



- *ar*：采样率

- *ac*：声道数

- f

  ：采样格式

  - *s16le*：PCM signed 16-bit little-endian
  - 更多PCM的采样格式可以使用命令查看
    - Windows：*ffmpeg -formats | findstr PCM*
    - Mac：*ffmpeg -formats | grep PCM*



`ffmpeg -formats | grep PCM`执行结果如下：

![022](https://github.com/winfredzen/VideoAudio/blob/main/Basic/image/022.png)



## 代码



+ [MyAudio](https://github.com/winfredzen/VideoAudio/tree/main/Basic/code/MyAudio)

















 
